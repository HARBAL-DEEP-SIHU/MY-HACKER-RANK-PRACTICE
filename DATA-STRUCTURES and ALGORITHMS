**Arrays - DS

import math
import os
import random
import re
import sys


def reverseArray(a):
    l = a[::-1]
    return l

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    arr_count = int(input().strip())

    arr = list(map(int, input().rstrip().split()))

    res = reverseArray(arr)

    fptr.write(' '.join(map(str, res)))
    fptr.write('\n')

    fptr.close()
    
     
 **Solve Me First
 
 def solveMeFirst(a,b):
  return a+b
	
 

num1 = int(input())
num2 = int(input())
res = solveMeFirst(num1,num2)
print(res)



**Simple Array Sum
import math
import os
import random
import re
import sys


def simpleArraySum(ar):
  s = 0
      
  for i in ar:   
    s= i+s
  return s
      

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ar_count = int(input().strip())

    ar = list(map(int, input().rstrip().split()))

    result = simpleArraySum(ar)

    fptr.write(str(result) + '\n')

    fptr.close()

**Compare the Triplets

import math
import os
import random
import re
import sys


def compareTriplets(a, b):
  
  alice = 0
  bob=0
  for i in range(0,3):
    if a[i]>b[i]:
      alice+=1
    if a[i]<b[i]:
      bob+=1
    
  return  [alice,bob]    
      

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    a = list(map(int, input().rstrip().split()))

    b = list(map(int, input().rstrip().split()))

    result = compareTriplets(a, b)

    fptr.write(' '.join(map(str, result)))
    fptr.write('\n')

    fptr.close()
    
**A Very Big Sum

import math
import os
import random
import re
import sys



def aVeryBigSum(ar):
  s=0
  for i in ar:
    s+=i
  return s  
    
    

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ar_count = int(input().strip())

    ar = list(map(int, input().rstrip().split()))

    result = aVeryBigSum(ar)

    fptr.write(str(result) + '\n')

    fptr.close()
    
    
**Diagonal Difference

import math
import os
import random
import re
import sys


def diagonalDifference(arr):
  s1=sum([arr[x][x] for x in range(len(arr))])
  s2= sum([arr[x][n-1-x] for x in range(len(arr))])
  return abs(s1-s2)

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    n = int(input().strip())

    arr = []

    for _ in range(n):
        arr.append(list(map(int, input().rstrip().split())))

    result = diagonalDifference(arr)

    fptr.write(str(result) + '\n')

    fptr.close()
    
    
**Plus Minus

import math
import os
import random
import re
import sys


def plusMinus(arr):
  c = (len(arr))
  p = 0
  n =0
  z=0
  for i in range(len(arr)):
    if arr[i] < 0:
      n+=1
    elif arr[i]>0:
      p+=1
    else:
      z+=1
  print('%f'%(p/c))
  print('%f'%(n/c))
  print('%f'%(z/c))  
  
  
if __name__ == '__main__':
    n = int(input().strip())

    arr = list(map(int, input().rstrip().split()))

    plusMinus(arr)
    
** Staircase

import math
import os
import random
import re
import sys

def staircase(n):
  for i in range(1,n+1):
    print(f'{"#"*i:>{n}}')

if __name__ == '__main__':
    n = int(input().strip())

    staircase(n)
    
**Mini-Max Sum
import math
import os
import random
import re
import sys

def miniMaxSum(arr):
  a = sorted(arr)
  print(sum(a[:-1]),sum(a[1:]))


if __name__ == '__main__':

    arr = list(map(int, input().rstrip().split()))

    miniMaxSum(arr)
    
**Birthday Cake Candles

import math
import os
import random
import re
import sys

def birthdayCakeCandles(candles):
  count = 0
  m = max(candles)
  for i in candles:
    if i ==m:
      count+=1
  return count    
 
  
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    candles_count = int(input().strip())

    candles = list(map(int, input().rstrip().split()))

    result = birthdayCakeCandles(candles)

    fptr.write(str(result) + '\n')

    fptr.close()

**2D Array - DS
import math
import os
import random
import re
import sys

def hourglassSum(arr):
  max_sum=-50000
  for i in range(0,4):
    for j in range(0,4):
      sum = (arr[i][j]+arr[i][j+1]+arr[i][j+2])+(arr[i+1][j+1])+(arr[i+2][j]+arr[i+2][j+1]+arr[i+2][j+2])
      if (sum>max_sum):
      
        max_sum = sum
      else: continue
  return max_sum      
           

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    arr = []

    for _ in range(6):
        arr.append(list(map(int, input().rstrip().split())))

    result = hourglassSum(arr)

    fptr.write(str(result) + '\n')

    fptr.close()

**Dynamic Array

import math
import os
import random
import re
import sys

def dynamicArray(n, queries):
  seq = [[] for _ in range(n)]
  last_answer=0
  result = []
  
  for q,x,y in queries:
    if q==1:
      idx = (x^last_answer)%n
      seq[idx].append(y)
    else:
      idx = (x^last_answer) %n
      last_answer = seq[idx][y% len(seq[idx])] 
      result.append(last_answer)
  return result    

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    q = int(first_multiple_input[1])

    queries = []

    for _ in range(q):
        queries.append(list(map(int, input().rstrip().split())))

    result = dynamicArray(n, queries)

    fptr.write('\n'.join(map(str, result)))
    fptr.write('\n')

    fptr.close()

**Left Rotation

import math
import os
import random
import re
import sys

def rotateLeft(d, arr):
  return (arr[d:]+arr[:d])
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    d = int(first_multiple_input[1])

    arr = list(map(int, input().rstrip().split()))

    result = rotateLeft(d, arr)

    fptr.write(' '.join(map(str, result)))
    fptr.write('\n')

    fptr.close()
    
    
**Sparse Arrays
import math
import os
import random
import re
import sys

def matchingStrings(strings, queries):
  result=[]
  for q in queries:
    arr=[x for x in strings if x==q]
    result.append(len(arr))
  return result  
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    strings_count = int(input().strip())

    strings = []

    for _ in range(strings_count):
        strings_item = input()
        strings.append(strings_item)

    queries_count = int(input().strip())

    queries = []

    for _ in range(queries_count):
        queries_item = input()
        queries.append(queries_item)

    res = matchingStrings(strings, queries)

    fptr.write('\n'.join(map(str, res)))
    fptr.write('\n')

    fptr.close()


**Array Manipulation
import math
import os
import random
import re
import sys

def arrayManipulation(n, queries):
    acc = {}
    for [a, b, k] in queries:
        acc[a] = (acc[a] if a in acc else 0) + k
        acc[b+1] = (acc[b+1] if b+1 in acc else 0) - k

    last = 0
    m = 0
    for i in range(1,n+1):
        curr = acc[i] if i in acc else 0
        last = last + curr
        if (last > m):
            m = last

    return m
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    m = int(first_multiple_input[1])

    queries = []

    for _ in range(m):
        queries.append(list(map(int, input().rstrip().split())))

    result = arrayManipulation(n, queries)

    fptr.write(str(result) + '\n')

    fptr.close()


**Print the Elements of a Linked List

def printLinkedList(head):
  temp = head
  while temp!=None:
    print(temp.data)
    temp= temp.next
    
**Insert a Node at the Tail of a Linked List  

def insertNodeAtTail(head, data):
  node = SinglyLinkedListNode(data)
  
  if head == None:
    head = node
  else: 
    temp = head
    while temp.next!= None:
      temp = temp.next
    temp.next = node  
  return head   

**Insert a node at the head of a linked list

def insertNodeAtHead(llist, data):
  node = SinglyLinkedListNode(data)
  if llist != None:
    node.next=llist
  return node 
  
**Insert a node at a specific position in a linked list  

def insertNodeAtPosition(head, data, position):
  node = SinglyLinkedListNode(data)
  if head ==None:
    head = node
  else:
    temp = head 
    count =1
    while temp!=None and count < position:
      temp = temp.next
      count+= 1
    node.next = temp.next 
    temp.next = node
  return head    
      
** Delete a Node
def deleteNode(head, position):
  if position == 0:
    head = head.next 
  else:
    temp =head
    count = 1
    while temp !=None and count<position:
      temp = temp.next 
      count+=1
    temp.next = temp.next.next
  return head      
  
**Print in Reverse

def reversePrint(head):
    if head is None:
        return
    else:
        out = []
        node = head
        
        while node != None:
            out.append(node.data)
            node = node.next
            
        print("\n".join(map(str, out[::-1])))


**Reverse a linked list

def reverse(head):
  prev = None
  cur = head 
  nxt = head.next
  while cur!=None:
    nxt = cur.next
    cur.next = prev
    prev=cur
    cur =nxt
  head = prev
  return head
  
  
**Compare two linked lists

def compare_lists(head1, head2):
  while head1 and head2:
    if head1.data == head2.data:
      
      head1 = head1.next
      head2 = head2.next
      #return 1
    else: return 0
  
  if head1 == None and head2 ==None:
    return 1
  else: return 0
  
**Merge two sorted linked lists

sys.setrecursionlimit(100000)
def mergeLists(head1, head2):
  if head1 == None and head2==None:
    return None
  if head1 ==None:
    return head2
  if head2 == None:
    return head1
  
  temp = 0
  if head1.data<head2.data:
    temp =head1
    temp.next = mergeLists(head1.next, head2)
  else:
    temp = head2
    temp.next = mergeLists(head2.next, head1)  
  return temp  
  
**Get Node Value

def getNode(head, positionFromTail):
  ptr1 =head
  ptr2 = head
  for i in range(positionFromTail):
    ptr1 = ptr1.next
    
  while ptr1.next != None:
    ptr1 = ptr1.next
    ptr2 = ptr2.next
  return ptr2.data    
  
**Delete duplicate-value nodes from a sorted linked list

def removeDuplicates(headd):
  head=headd
  while head.next:
    if head.data == head.next.data:
      head.next= head.next.next
    else:
      head = head.next  
      
  return headd
  
**Find Merge Point of Two Lists

def findMergeNode(head1, head2):
  def getcount(head):
    n=0
    while head.next:
      n+=1
      head = head.next 
    return n  
 
  def getnode(d,head1,head2):
    for i in range(d):
      head1 =head1.next  
    while head1 and head2:
    
      if head1==head2:
        return head1.data
      else:
        head1 = head1.next
        head2 = head2.next
      
  c1 = getcount(head1)
  c2 = getcount(head2)
  
  if c1>c2:
    return getnode(c1-c2, head1, head2)
  else:
    return getnode(c2-c1, head2, head1)
    
** Inserting a Node Into a Sorted Doubly Linked List

def sortedInsert(head, data):
  node = DoublyLinkedListNode(data)
  if head == None:
    head = node  
  elif data < head.data:
    node.next = head
    head.prev = node
    head = node
    
  else:
    cur = head
    while cur.next!=None and cur.data<data:
      cur = cur.next
    if cur.next ==None and cur.data<data:
      cur.next = node
      node.prev = cur
      
    else:
      previous = cur.prev
      previous.next = node
      node.prev = previous
      node.next = cur
      cur.prev = node
  return head  
  
** Reverse a doubly linked list

def reverse(head):
  while head.next!= None:
    head.next, head.prev, head = head.prev, head.next, head.next
  head.next, head.prev = head.prev , None
  return head  
  
**Tree: Preorder Traversal

def preOrder(root):
  if root:
    print(root.info,end = ' ')
    preOrder(root.left)
    preOrder(root.right)
    
 **Tree: Postorder Traversal
 
 def postOrder(root):
  if root:
 
    postOrder(root.left)
    postOrder(root.right)
    print(root.info, end = " ")
    
 **Tree: Inorder Traversal
 
 def inOrder(root):
  if root:
    
    inOrder(root.left)
    print(root.info , end = ' ')
    inOrder(root.right)


**Tree: Height of a Binary Tree

def height(root):
  if root == None:
    return -1
  else:
    return 1 + max(height(root.left), height(root.right))

**Tree : Top View

def topView(root):
  d = {}
  def traverse(root, key, level):
    if root:
      if key not in d:
        d[key]=[root,level]
      elif d[key][1]>level:
        d[key]=[root,level]
      traverse(root.left , key -1 , level +1)  
      traverse(root.right, key +1, level +1)
  traverse(root, 0, 0)
  for key in sorted(d):
    print(d[key][0],end = ' ')
    
    
  
  

      
      
 















