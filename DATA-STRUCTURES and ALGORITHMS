**Arrays - DS

import math
import os
import random
import re
import sys


def reverseArray(a):
    l = a[::-1]
    return l

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    arr_count = int(input().strip())

    arr = list(map(int, input().rstrip().split()))

    res = reverseArray(arr)

    fptr.write(' '.join(map(str, res)))
    fptr.write('\n')

    fptr.close()
    
     
 **Solve Me First
 
 def solveMeFirst(a,b):
  return a+b
	
 
**Grid Challenge
num1 = int(input())
num2 = int(input())
res = solveMeFirst(num1,num2)
print(res)



**Simple Array Sum
import math
import os
import random
import re
import sys


def simpleArraySum(ar):
  s = 0
      
  for i in ar:   
    s= i+s
  return s
      

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ar_count = int(input().strip())

    ar = list(map(int, input().rstrip().split()))

    result = simpleArraySum(ar)

    fptr.write(str(result) + '\n')

    fptr.close()

**Compare the Triplets

import math
import os
import random
import re
import sys


def compareTriplets(a, b):
  
  alice = 0
  bob=0
  for i in range(0,3):
    if a[i]>b[i]:
      alice+=1
    if a[i]<b[i]:
      bob+=1
    
  return  [alice,bob]    
      

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    a = list(map(int, input().rstrip().split()))

    b = list(map(int, input().rstrip().split()))

    result = compareTriplets(a, b)

    fptr.write(' '.join(map(str, result)))
    fptr.write('\n')

    fptr.close()
    
**A Very Big Sum

import math
import os
import random
import re
import sys



def aVeryBigSum(ar):
  s=0
  for i in ar:
    s+=i
  return s  
    
    

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ar_count = int(input().strip())

    ar = list(map(int, input().rstrip().split()))

    result = aVeryBigSum(ar)

    fptr.write(str(result) + '\n')

    fptr.close()
    
    
**Diagonal Difference

import math
import os
import random
import re
import sys


def diagonalDifference(arr):
  s1=sum([arr[x][x] for x in range(len(arr))])
  s2= sum([arr[x][n-1-x] for x in range(len(arr))])
  return abs(s1-s2)

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    n = int(input().strip())

    arr = []

    for _ in range(n):
        arr.append(list(map(int, input().rstrip().split())))

    result = diagonalDifference(arr)

    fptr.write(str(result) + '\n')

    fptr.close()
    
    
**Plus Minus

import math
import os
import random
import re
import sys


def plusMinus(arr):
  c = (len(arr))
  p = 0
  n =0
  z=0
  for i in range(len(arr)):
    if arr[i] < 0:
      n+=1
    elif arr[i]>0:
      p+=1
    else:
      z+=1
  print('%f'%(p/c))
  print('%f'%(n/c))
  print('%f'%(z/c))  
  
  
if __name__ == '__main__':
    n = int(input().strip())

    arr = list(map(int, input().rstrip().split()))

    plusMinus(arr)
    
** Staircase

import math
import os
import random
import re
import sys

def staircase(n):
  for i in range(1,n+1):
    print(f'{"#"*i:>{n}}')

if __name__ == '__main__':
    n = int(input().strip())

    staircase(n)
    
**Mini-Max Sum
import math
import os
import random
import re
import sys

def miniMaxSum(arr):
  a = sorted(arr)
  print(sum(a[:-1]),sum(a[1:]))


if __name__ == '__main__':

    arr = list(map(int, input().rstrip().split()))

    miniMaxSum(arr)
    
**Birthday Cake Candles

import math
import os
import random
import re
import sys

def birthdayCakeCandles(candles):
  count = 0
  m = max(candles)
  for i in candles:
    if i ==m:
      count+=1
  return count    
 
  
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    candles_count = int(input().strip())

    candles = list(map(int, input().rstrip().split()))

    result = birthdayCakeCandles(candles)

    fptr.write(str(result) + '\n')

    fptr.close()

**2D Array - DS
import math
import os
import random
import re
import sys

def hourglassSum(arr):
  max_sum=-50000
  for i in range(0,4):
    for j in range(0,4):
      sum = (arr[i][j]+arr[i][j+1]+arr[i][j+2])+(arr[i+1][j+1])+(arr[i+2][j]+arr[i+2][j+1]+arr[i+2][j+2])
      if (sum>max_sum):
      
        max_sum = sum
      else: continue
  return max_sum      
           

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    arr = []

    for _ in range(6):
        arr.append(list(map(int, input().rstrip().split())))

    result = hourglassSum(arr)

    fptr.write(str(result) + '\n')

    fptr.close()

**Dynamic Array

import math
import os
import random
import re
import sys

def dynamicArray(n, queries):
  seq = [[] for _ in range(n)]
  last_answer=0
  result = []
  
  for q,x,y in queries:
    if q==1:
      idx = (x^last_answer)%n
      seq[idx].append(y)
    else:
      idx = (x^last_answer) %n
      last_answer = seq[idx][y% len(seq[idx])] 
      result.append(last_answer)
  return result    

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    q = int(first_multiple_input[1])

    queries = []

    for _ in range(q):
        queries.append(list(map(int, input().rstrip().split())))

    result = dynamicArray(n, queries)

    fptr.write('\n'.join(map(str, result)))
    fptr.write('\n')

    fptr.close()

**Left Rotation

import math
import os
import random
import re
import sys

def rotateLeft(d, arr):
  return (arr[d:]+arr[:d])
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    d = int(first_multiple_input[1])

    arr = list(map(int, input().rstrip().split()))

    result = rotateLeft(d, arr)

    fptr.write(' '.join(map(str, result)))
    fptr.write('\n')

    fptr.close()
    
    
**Sparse Arrays
import math
import os
import random
import re
import sys

def matchingStrings(strings, queries):
  result=[]
  for q in queries:
    arr=[x for x in strings if x==q]
    result.append(len(arr))
  return result  
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    strings_count = int(input().strip())

    strings = []

    for _ in range(strings_count):
        strings_item = input()
        strings.append(strings_item)

    queries_count = int(input().strip())

    queries = []

    for _ in range(queries_count):
        queries_item = input()
        queries.append(queries_item)

    res = matchingStrings(strings, queries)

    fptr.write('\n'.join(map(str, res)))
    fptr.write('\n')

    fptr.close()


**Array Manipulation
import math
import os
import random
import re
import sys

def arrayManipulation(n, queries):
    acc = {}
    for [a, b, k] in queries:
        acc[a] = (acc[a] if a in acc else 0) + k
        acc[b+1] = (acc[b+1] if b+1 in acc else 0) - k

    last = 0
    m = 0
    for i in range(1,n+1):
        curr = acc[i] if i in acc else 0
        last = last + curr
        if (last > m):
            m = last

    return m
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    first_multiple_input = input().rstrip().split()

    n = int(first_multiple_input[0])

    m = int(first_multiple_input[1])

    queries = []

    for _ in range(m):
        queries.append(list(map(int, input().rstrip().split())))

    result = arrayManipulation(n, queries)

    fptr.write(str(result) + '\n')

    fptr.close()


**Print the Elements of a Linked List

def printLinkedList(head):
  temp = head
  while temp!=None:
    print(temp.data)
    temp= temp.next
    
**Insert a Node at the Tail of a Linked List  

def insertNodeAtTail(head, data):
  node = SinglyLinkedListNode(data)
  
  if head == None:
    head = node
  else: 
    temp = head
    while temp.next!= None:
      temp = temp.next
    temp.next = node  
  return head   

**Insert a node at the head of a linked list

def insertNodeAtHead(llist, data):
  node = SinglyLinkedListNode(data)
  if llist != None:
    node.next=llist
  return node 
  
**Insert a node at a specific position in a linked list  

def insertNodeAtPosition(head, data, position):
  node = SinglyLinkedListNode(data)
  if head ==None:
    head = node
  else:
    temp = head 
    count =1
    while temp!=None and count < position:
      temp = temp.next
      count+= 1
    node.next = temp.next 
    temp.next = node
  return head    
      
** Delete a Node
def deleteNode(head, position):
  if position == 0:
    head = head.next 
  else:
    temp =head
    count = 1
    while temp !=None and count<position:
      temp = temp.next 
      count+=1
    temp.next = temp.next.next
  return head      
  
**Print in Reverse

def reversePrint(head):
    if head is None:
        return
    else:
        out = []
        node = head
        
        while node != None:
            out.append(node.data)
            node = node.next
            
        print("\n".join(map(str, out[::-1])))


**Reverse a linked list

def reverse(head):
  prev = None
  cur = head 
  nxt = head.next
  while cur!=None:
    nxt = cur.next
    cur.next = prev
    prev=cur
    cur =nxt
  head = prev
  return head
  
  
**Compare two linked lists

def compare_lists(head1, head2):
  while head1 and head2:
    if head1.data == head2.data:
      
      head1 = head1.next
      head2 = head2.next
      #return 1
    else: return 0
  
  if head1 == None and head2 ==None:
    return 1
  else: return 0
  
**Merge two sorted linked lists

sys.setrecursionlimit(100000)
def mergeLists(head1, head2):
  if head1 == None and head2==None:
    return None
  if head1 ==None:
    return head2
  if head2 == None:
    return head1
  
  temp = 0
  if head1.data<head2.data:
    temp =head1
    temp.next = mergeLists(head1.next, head2)
  else:
    temp = head2
    temp.next = mergeLists(head2.next, head1)  
  return temp  
  
**Get Node Value

def getNode(head, positionFromTail):
  ptr1 =head
  ptr2 = head
  for i in range(positionFromTail):
    ptr1 = ptr1.next
    
  while ptr1.next != None:
    ptr1 = ptr1.next
    ptr2 = ptr2.next
  return ptr2.data    
  
**Delete duplicate-value nodes from a sorted linked list

def removeDuplicates(headd):
  head=headd
  while head.next:
    if head.data == head.next.data:
      head.next= head.next.next
    else:
      head = head.next  
      
  return headd
  
**Find Merge Point of Two Lists

def findMergeNode(head1, head2):
  def getcount(head):
    n=0
    while head.next:
      n+=1
      head = head.next 
    return n  
 
  def getnode(d,head1,head2):
    for i in range(d):
      head1 =head1.next  
    while head1 and head2:
    
      if head1==head2:
        return head1.data
      else:
        head1 = head1.next
        head2 = head2.next
      
  c1 = getcount(head1)
  c2 = getcount(head2)
  
  if c1>c2:
    return getnode(c1-c2, head1, head2)
  else:
    return getnode(c2-c1, head2, head1)
    
** Inserting a Node Into a Sorted Doubly Linked List

def sortedInsert(head, data):
  node = DoublyLinkedListNode(data)
  if head == None:
    head = node  
  elif data < head.data:
    node.next = head
    head.prev = node
    head = node
    
  else:
    cur = head
    while cur.next!=None and cur.data<data:
      cur = cur.next
    if cur.next ==None and cur.data<data:
      cur.next = node
      node.prev = cur
      
    else:
      previous = cur.prev
      previous.next = node
      node.prev = previous
      node.next = cur
      cur.prev = node
  return head  
  
** Reverse a doubly linked list

def reverse(head):
  while head.next!= None:
    head.next, head.prev, head = head.prev, head.next, head.next
  head.next, head.prev = head.prev , None
  return head  
  
**Tree: Preorder Traversal

def preOrder(root):
  if root:
    print(root.info,end = ' ')
    preOrder(root.left)
    preOrder(root.right)
    
 **Tree: Postorder Traversal
 
 def postOrder(root):
  if root:
 
    postOrder(root.left)
    postOrder(root.right)
    print(root.info, end = " ")
    
 **Tree: Inorder Traversal
 
 def inOrder(root):
  if root:
    
    inOrder(root.left)
    print(root.info , end = ' ')
    inOrder(root.right)


**Tree: Height of a Binary Tree

def height(root):
  if root == None:
    return -1
  else:
    return 1 + max(height(root.left), height(root.right))

**Tree : Top View

def topView(root):
  d = {}
  def traverse(root, key, level):
    if root:
      if key not in d:
        d[key]=[root,level]
      elif d[key][1]>level:
        d[key]=[root,level]
      traverse(root.left , key -1 , level +1)  
      traverse(root.right, key +1, level +1)
  traverse(root, 0, 0)
  for key in sorted(d):
    print(d[key][0],end = ' ')
    
 ** Tree: Level Order Traversal
 from collections import deque
def levelOrder(root):
  q = deque([root])
  while len(q):
    root = q.popleft()
    print(root,end = ' ')
    if root.left: q.append(root.left)
    if root.right:q.append(root.right)
    
**Binary Search Tree : Insertion

    def insert(self, val):
      newnode = Node(val)
      if self.root is None:
        self.root = newnode
        return self
      cur = self.root
      while cur:
        if val < cur.info:
          if cur.left is None:
            cur.left = newnode
            return self
          cur = cur.left
        else:
          if cur.right is None:
            cur.right = newnode
            return self
          cur = cur.right
	  
	  
**Binary Search Tree : Lowest Common Ancestor

def lca(root, v1, v2):
  if v1>v2:
    v1,v2 = v2, v1
  while True:
    if v1<root.info and v2<root.info:
      root = root.left
    elif v1>root.info and v2>root.info:
      root = root.right
    else:
      return root
  
 **QHEAP1
 
 from heapq import heappush, heappop
heap = []
lookup = set()
for i in range(int(input())):
  t = list(map(int,input().split()))
  
  if t[0] == 1:
    heappush(heap, t[1])
    lookup.add(t[1])
  elif t[0] == 2:
    lookup.discard(t[1])
    
  else: 
    while heap[0] not in lookup:
      heappop(heap)
    print (heap[0])


**Maximum Element

stack = []
for _ in range(int(input())):
  q = list(map(int,input().split()))
  
  
  if q[0] ==1:
    if stack:
      stack.append(max(stack[-1],q[1]))
    else:
      stack.append(q[1])
  elif q[0] ==2:
    stack.pop()
  else:
    print(stack[-1])
  
 
**Jesse and Cookies

def cookies(k, a):
  heapify(a)
  count = 0
  while True:
    x = heappop(a)
    if x>=k:
      return count
    if a:
      y = heappop(a)
      s = x +y*2
      heappush(a,s)
      count +=1
    else:
      return -1  
      
  **Equal Stacks   
  
  def equalStacks(h1, h2, h3):
  h1 = h1[::-1]
  h2 = h2[::-1]
  h3=h3[::-1]
  
  sum1 = sum(h1)
  sum2 = sum(h2)
  sum3 = sum(h3)
  
  while True:
    minheight = min(sum1, sum2,sum3)
    if minheight ==0:
      return 0
    else:
      if minheight<sum1:
        sum1 -= h1.pop()
      elif minheight<sum2:
        sum2 -= h2.pop()
      elif minheight<sum3:
        sum3 -= h3.pop()
      else:
        if sum1 == sum2 ==sum3:
          return sum1
  
  **Grading Students
  
  def gradingStudents(grades):
  g= []
  for i in grades:
    if i>=38:
      m = i%5
      if m >=3:
        i += (5-m)
    g.append(i)
  return g  
  
 **Apple and Orange
 
 def countApplesAndOranges(s, t, a, b, apples, oranges):
  tapples= toranges = 0
  for i in range(len(apples)):
    if s<= a+apples[i] <=t:
      tapples+=1
  for i in range(len(oranges)):
    if s<= b+ oranges[i]<=t:
      toranges+=1
  print(tapples)
  print(toranges)
  
**Number Line Jumps

def kangaroo(x1, v1, x2, v2):
  if x1<x2 and v1<v2:
    return 'NO'
  else:
    if v1!=v2 and (x2-x1)%(v1-v2)==0:
      return "YES"
    else: return 'NO'
    
 **Between Two Sets
 
 from functools import reduce
def getTotalX(a, b):
  def gcd(a,b):
    if b==0:
      return a
    return gcd(b,a%b)
  def lcm(a,b):
    return  (a*b//gcd(a,b))
  l = reduce(lcm,a)
  g = reduce(gcd,b)
  s=0
  for i in range(l,g+1,l):
    if g%i==0:
      s+=1
  return s
  
** Breaking the Records

def breakingRecords(scores):
  minimum = scores[0]
  maximum = scores[0]
  min_count = 0
  max_count = 0
  for i in range(len(scores)):
    if minimum > scores[i]:
      minimum = scores[i]
      min_count +=1
    if maximum < scores[i]:
      maximum = scores[i]
      max_count +=1
  
  return max_count,min_count
  
  
 **Subarray Division
 
 def birthday(s, d_sum, m_num):
  count = 0
  total = sum(s[:m_num])
  
  if total == d_sum:
    count +=1
  for i in range(m_num, len(s)):
    total += s[i]
    total -= s[i-m_num] 
    if total == d:
      count+=1

  return count
  
**Divisible Sum Pairs

def divisibleSumPairs(n, k, ar):
  i = 0
  count = 0
  for i in range(n):
    for j in range(i+1, n):
      if (ar[i]+ar[j])%k ==0:
        count +=1
  return count

**Migratory Birds

def migratoryBirds(arr):
  l = [0] * len(arr)
  for i in range(len(arr)):
    l[arr[i]]+=1
  return l.index(max(l))
  
 ** Day of the Programmer
 
 def dayOfProgrammer(year):
  if (year<1917 and year%4==0) or  (year>1918 and (year% 400 ==0 or (year %4==0 and year%100!=0))):
    
    return "12.09.%s" %year
  elif year == 1918:
    return '26.09.1918'
  else :
    return '13.09.%s' %year 
    
    
  ** Bill Division
  def bonAppetit(bill, k, b):
    sum_b = sum(bill)
    sum_anna = (sum_b - bill[k])//2
    if sum_anna == b:
      print('Bon Appetit')
    else:
      print (b - sum_anna)
      
 ** Drawing Book
 
 def pageCount(n, p):
  front = p//2
  if n%2==1:
    back = (n-p)//2
  else: 
    back = (n-p+1)//2
  
  return min(front, back)
  
  
 **Counting Valleys
 
 def countingValleys(steps, path):
  valley , level = 0,0
  d = {'U':1, 'D':-1}
  for i in path:
    level += d[i]
    if level == 0 and i == 'U':
      valley += 1
  return valley
  
** Electronics Shop
def getMoneySpent(keyboards, drives, b):
  l = []
  for i in keyboards:
    for j in drives:
      if i+j <=b:
        l.append(i+j)
      else:
        l.append(-1) 
	
**Cats and a Mouse

def catAndMouse(x, y, z):
  cat_A ,cat_B = abs(x-z), abs(y-z)
  if cat_A == cat_B:
    return 'Mouse C'
  elif cat_A<cat_B:
    return 'Cat A'
  else:
    return 'Cat B'
    
 **Forming a Magic Square
 import itertools
s = []
for i in range(3):
    s.extend(list(map(int, input().split(" "))))
min_cost = 1000
best = None
def is_magic(s):
    for i in range(3):
        if sum(s[i*3:i*3+3]) != 15:
            return False
        if sum(s[i::3]) != 15:
            return False
    if s[0] + s[4] + s[8] != 15:
        return False
    if s[2] + s[4] + s[6] != 15:
        return False
    return True
best = None
for p in itertools.permutations(range(1,10)):
    cost = sum([abs(p[i] - s[i]) for i in range(len(s))])
    if cost < min_cost and is_magic(p):
        min_cost = cost
        best = p
        
print(min_cost)
  
  
**Picking Numbers

from collections import Counter
def pickingNumbers(a):
  arr = Counter(a)
  max_num = 0
  for i in range(100):
    max_num = max(max_num, arr[i]+arr[i+1])
  return max_num
  
** Climbing the Leaderboard

def climbingLeaderboard(ranked, player):
  scores = list(set(ranked))
  scores.sort()
  n = len(scores)
  i = 0
  result = []
  
  for j in player:
    while i<n and scores[i]<=j:
      i +=1
    result.append(n-i+1)
  return result


**The Hurdle Race

def hurdleRace(k, height):
  result = []
  for i in height:
    diff = (i-k)
    if i-k>0:
      result.append(diff)
    else:
      result.append(0)
  return max(result)
    
   
**Designer PDF Viewer

def designerPdfViewer(h, word):
  height = 0
  for i in word:
    height = max(height, h[ord(i) - ord('a')])
  return height*len(word) 
  

**Utopian Tree


def utopianTree(n):
  s = 0
  for i in range(n+1) :
    if i%2==0:
      s +=1
    else: 
      s =s*2
  
  return s
  
  
 **def angryProfessor(k, a):
  result = []
  for i in a:
    if i<=0:
      result.append(i)
  if k <= len(result):
    return 'NO'
  else:
     return 'YES'Angry Professor

**Beautiful Days at the Movies

def beautifulDays(i, j, k):
  count = 0
  for i in range(i,j+1):
    rev = int(str(i)[::-1])
    if abs(i - rev) %k == 0:
      count+=1
  return count

**Viral Advertising

def viralAdvertising(n):
  sum_likes = 0
  share = 5
  
  for i in range(n):
    likes = math.floor(share/2)
    sum_likes += likes
    share = likes * 3
    
  return sum_likes
  
  
** Save the Prisoner!

def saveThePrisoner(p , s, c):
  res = s + c - 1
  res %= p
  if res == 0:
    return p
  return res
  
 ** Circular Array Rotation
 
 def circularArrayRotation(a, k, queries):
  result = []
  k = k%n
  for q in queries:
    result.append(a[(n - k +q)%n])
  return result
  
 **Sequence Equation
 
 def permutationEquation(p):
  result = []
  n = len(p)
  for i in range(1, n+1):
    result.append(p.index(p.index(i)+1)+1)
  return result
  
  
  **Jumping on the Clouds: Revisited
  
  def jumpingOnClouds(c, k):
  e = 100
  i = 0
  while True:
    e = e - 1- 2 * c[i]
    i = (i+k)%n
    if i ==0:
      break
  return e
  
  
 **Find Digits
 
 def findDigits(n):
  count = 0
  for i in str(n):
   
    if int(i)!= 0 and n%int(i)==0:
      count+=1
  return count
  
  
** Extra Long Factorials

def extraLongFactorials(n):
  fact = 1
  for i in range(1,n+1):
    fact *= i
  print(fact)
  
  
** Append and Delete

def appendAndDelete(s, t, k):
  count = 0
  for i,j in zip(s,t):
    if i == j:
      count+= 1
    else:
      break
  t_len = len(s) + len(t)
  if t_len <= 2*count + k and t_len%2 == k%2 or t_len < k:
    return('Yes')
  else:
    return 'No'
    
    
 ** Sherlock and Squares
 
 def squares(a, b):
  return math.floor(math.sqrt(b)) - (math.ceil(math.sqrt(a))) +1

**Library Fine

def libraryFine(d1, m1, y1, d2, m2, y2):
  total = 0
  if y1>y2:
    total += 10000
  elif y1==y2 and m1>m2:
    total += 500 * (m1-m2)
  elif y1==y2 and m1 ==m2 and d1>d2:
    total += 15 *(d1-d2)

  return total    
  
 **Cut the sticks
 
 from collections import Counter
def cutTheSticks(arr):
  res = []
  n = len(arr)
  s = Counter(arr)
  for i in sorted(s.keys()):
    res.append(n)
    n -= s[i]
  return res
  
  
 **Repeated String
 
 def repeatedString(s, n):
  count = 0
  l = len(s)

  for i in s:
    if i =='a':
      count+=1
   
  count = n//l *count

  for i in s[:n%l]:
    if i == 'a':
      count+=1
  
  return count
  
 **Jumping on the Clouds
  
  def jump(c):
    res = 0
    ind = 0
    
    while ind != len(c)-1:
        if ind != len(c)-2 and c[ind+2] == 0:
            ind += 2
        else:
            ind += 1
        res += 1
        
    return res
    
  ** Equalize the Array
  
  from collections import Counter
def equalizeArray(arr):
  c = Counter(arr)
  return len(arr) - max(c.values())
  
 **ACM ICPC Team
 
 def acmTeam(topic):
  maxsub = 0
  count = 0
  for i in range(n):
    for j in range(i,n):
      sub = 0
      for x, y in zip(topic[i] , topic[j]):
        if x== '1' or y == '1':
          sub+=1
      print(sub)
      if sub > maxsub:
        maxsub = sub
        count  = 1
      elif maxsub == sub: 
        count +=1
  return [maxsub ,count] 
  
** Taum and B'day

def taumBday(b, w, bc, wc, z):
  return min(b*bc + w*wc , bc*(w+b) + (w*z) , (wc*(b+w)) + b*z)
  

**Organizing Containers of Balls
def organizingContainers(container):
  row = [0] * n
  col = [0] * n
  for i in range(n):
    for j in range(n):
      row[i] += container[i][j]
      col[i] += container[j][i]
  if sorted(row) == sorted(col):
    return 'Possible'
  else:
    return 'Impossible'  
    
 **Encryption   
 
 def encryption(s):
  l = len(s)
  row = math.floor(math.sqrt(l))
  col = math.ceil(math.sqrt(l))
  result = []
  
  for i in range(col):
    temp = [] 
    j = 0
    while i+j < l:
      temp.append(s[i+j])
      j += col
    result.append("" . join(temp))
  return ' '.join(result) 
  
  
** Modified Kaprekar Numbers

def kaprekarNumbers(p, q):
  result = []
  for i in range(p,q+1):
    s = str(i*i)
    n = len(s)
    if i ==1:
      result.append(i)
    elif n>1 and i == int(s[:n//2]) + int(s[n//2:]):
      result.append(i)
  if len(result) == 0 :
    print('INVALID RANGE')
  else:
    print(*result)

** Beautiful Triplets

from collections import Counter
def beautifulTriplets(d, arr):
  n = Counter(arr)
  count = 0
  for i in arr:
    if n[i + d] and n[ i + d + d]:
      count +=1
  return count
  
** Minimum Distances

def minimumDistances(a):
  distance = []
  for i in range(n):
    for j in range(i+1,n):
      if a[i] == a[j]:
        distance.append(j-i)
  if distance:
    return min(distance)
  else:
    return -1
    
    
**Halloween Sale

def howManyGames(p, d, m, s):
  games = 0
  while p<=s:
    s -=p
    p = max(p-d , m)
    games += 1
  return games
  
  
 **Chocolate Feast
 
 def chocolateFeast(n, c, m):
  choco = n//c
  wraps = choco
  while wraps >=m:
    choco += wraps//m
    wraps = wraps //m + wraps%m
  return choco
  
  
 ** Service Lane
 
 def serviceLane(n, cases):
  result = []
  for i,j in cases:
    result.append(min(width[i:j+1]))
  return result
  
  
** Lisa's Workbook

def workbook(n, k, arr):
  count = 0
  page = 1
  for i in arr:
    for j in range(1,i+1):
      if j == page:
        count+=1
      if i == j or j%k ==0:
        page+=1
  return count
   
 **Flatland Space Stations
 
 def flatlandSpaceStations(n, c):
  answer = 0
  c.sort()
  for i in range(1,len(c)):
    answer = max(answer , (c[i]-c[i-1])//2)
  answer = max(answer , c[0] , n-1 -c[-1])
  return answer
  
  **Fair Rations
  
  def fairRations(B):
  breads = 0
  n = len(B)
  for i in range(n-1):
    if B[i]%2==1:
      breads +=2 
      B[i+1] +=1
  if B[n-1]%2==1:
    return "NO"
  else:
    return str(breads)   
    
 ** Cavity Map

def cavityMap(grid):
  grid = [list(x) for x in grid]
  for i in range(1,n-1):
    for j in range(1,n-1):
      if grid[i][j] > grid[i-1][j] and grid[i][j] > grid[i+1][j] and grid[i][j] > grid[i][j-1] and grid[i][j] > grid[i][j+1] :
        grid[i][j] = "X"
        
  return (''.join(x)for x in grid)

    
  ** Manasa and Stones
  
  def stones(n, a, b):
  result = set()
  if a>b:
    a,b = b,a
  for i in range(n):
    result.add(i*a + (n-1 -i)*b)
  return sorted(list(result))

**Happy Ladybugs

from collections import Counter
def happyLadybugs(b):
  bugs = Counter(b)
  for i, j in bugs.items():
    if i != "_" and j ==1:
      return 'NO'
      
  if bugs['_'] > 0:
    return 'YES'
  else:
    pair = 0
    for i in range(len(b) - 1):
      if b[i] == b[i+1]:
        pair+=1
      elif pair>0:
        pair = 0
      else:
        return 'NO'
    return 'YES'
    
  **Strange Counter
  
 def strangeCounter(t):
  time = 3
  while True:
    t -= time
    if t<=0:
      t +=time
      return time - t + 1
    time *= 2
  return time
  
  
 **Super Reduced String
 
 def superReducedString(s):
  result = []
  for i in range(len(s)):
    if len(result) == 0 or result[-1] != s[i]:
      result.append(s[i])
    else:
      result.pop()
  if len(result) == 0:
    return 'Empty String'
  else:
    return ''.join(result)
    
   
 **CamelCase
 def camelcase(s):
  count = 1
  for i in s:
    if i.isupper():
      count+=1
  return count


**Strong Password

def minimumNumber(n, password):
  special = "!@#$%^&*()-+" 
  l =[0,0,0,0]
  
  for i in password:
    if i.isdigit():
      l[0] =1
    elif i.isupper():
      l[1] =1
    elif i.islower():
      l[2]=1
    elif i in special:
      l[3] = 1
    
  return max(6-len(password ), 4 - sum(l))
  
** Two Characters

def alternate(s):
  maxnum = count = 0
  a = list(set(s))
  for i in range(len(a)):
    for j in range(i+1 , len(a)):
      l = [a[i] , a[j]]
      
      if s.index(a[i]) < s.index(a[j]):
        ind = 0
      else:
        ind = 1 
        
      for char in s:
        if char in l:
          if char == l[ind]:
            count += 1
            ind = ind ^ 1
          else:
            count = 0
            break
          
      maxnum = max(maxnum , count)
      count = 0
  return maxnum

**Caesar Cipher

def caesarCipher(s, k):
  temp = []
  for char in s:
    temp.append(ord(char))
    
  for i in range(n):
    if 65 <= temp[i] <=90:
      temp[i] = (65 + (temp[i] -65 +k)%26)
      
    elif 97 <= temp[i] <=122:
      temp[i] = (97 + (temp[i] -97 +k)%26)
  return (''.join(map(chr, temp))) 
  
  
  **Mars Exploration
  
  
  def marsExploration(s):
  result =[]
  count = 0
  for i in range((len(s)//3)):
    result.append('SOS')
  ans = ''.join(result)

  for i,j in zip(s,ans):
    if i!=j:
      count+=1
  return count
 
 
** HackerRank in a String!

def hackerrankInString(s):
  target = 'hackerrank'
  n = len(target)
  i = 0
  for char in s:
    if char == target[i]:
      i+=1
      if i ==n:
        return 'YES'
  return 'NO'
  
** Pangrams

def pangrams(s):
  test = set(s.lower())-set(' ')

  if len(test) == 26:
    return 'pangram'
  else:
      return 'not pangram'
      
** Weighted Uniform Strings

def weightedUniformStrings(s, queries):
  result = []
  d= {}
  weight = 0
  for i in range(len(s)):
    if i ==0 or s[i] != s[i-1]:
      weight = ord(s[i]) - ord('a') + 1
    else:
      weight = weight +   ord(s[i]) - ord('a') + 1
    d[weight] =2
  for q in queries:
    result.append('Yes' if q in d else 'No') 
  return result
    


**Separate the Numbers

def separateNumbers(s):
  if len(s) == 1:
    print('NO')
    return
  else:
    for i in range(1, len(s) // 2 +1):
      g = s[:i]
      prev = int(g)
      while len(g) < len(s):
        next = prev +1 
        g = g + str(next)
        prev = next
        
      if g == s:
        print('YES' , s[:i])
        return
    print('NO')
    
  ** Funny String
  
  def funnyString(s):
  rev = s[::-1]
  for i in range(1, len(s)):
    if abs(ord(s[i]) - ord(s[i-1])) != abs(ord(rev[i]) - ord(rev[i-1])):
      return 'Not Funny'
    
  return 'Funny'

**Gemstones

def gemstones(arr):
  result = set(arr[0])
  for i in range(1,len(arr)):
    temp = set(arr[i])
    result = result.intersection(temp)
  return len(result)
    
    
** Alternating Characters
def alternatingCharacters(s):
  count = 0
  for i in range(len(s)-1):
    if ord(s[i]) - ord(s[i+1]) == 0:
      i = i+1
      count +=1
  return count
  
  
  
** Beautiful Binary String

def beautifulBinaryString(b):
  count = 0
  b=list(b)
  for i in range(len(b)-2):
    if b[i] == '0' and b[i+1] == '1' and b[i+2] == '0':
      count +=1
      b[i+2] = '1'   
  return count
  
  
 ** The Love-Letter Mystery
 
 def theLoveLetterMystery(s):
  count = 0
  for i in range((len(s)//2)):
    count += abs(ord(s[i] ) -  ord(s[len(s) - 1 - i]))
  return count
      
      
 ** Palindrome Index
 
 def palindromeIndex(s):
  if s ==s[::-1]:
    return -1
    
  for i in range(len(s)//2):
    
    if s[i] != s[len(s) - i -1]:
      if s[i:len(s) - i -1] == s[i: len(s) - i -1][::-1]:
        return (len(s) - i -1)
      elif s[i+1: len(s) - i] == s[i+1:len(s) - i][::-1]:
        return i
    
  return -1
  
 ** Anagram
 
 from collections import Counter
def anagram(s):
  n = len(s)
  if n%2==1:
    return -1
  s = Counter(s[:n//2]) - Counter(s[n//2:])
  return sum(s.values())
  
 ** Making Anagrams
 
 from collections import Counter
def makingAnagrams(s1, s2):
  total = len(s1) + len(s2)
  set1 = Counter(s1)
  set2 = Counter(s2)
  inter1 = set1 - set2
  inter2 = set2 - set1 
  ans1 = sum(inter1.values())
  ans2 = sum(inter2.values())
  return ans1 + ans2
  
 ** Game of Thrones - I
 
 from collections import Counter
def gameOfThrones(s):
  total = 0
  s= Counter(s)
  for key,values in s.items():
    total += values%2
  if total>1:
    return 'NO'
  else:
    return 'YES'
  
 
**Two Strings   

def twoStrings(s1, s2):
  s1 = set(s1)
  s2 =set(s2)
  if s1.intersection(s2):
    return 'YES'
  else:
    return 'NO'
    
 **String Construction
 
 def stringConstruction(s):
  return len(set(s))
  
  
** Big Sorting

def bigSorting(unsorted):
  unsorted.sort(key = lambda x: (len(x) , x))
  return unsorted
  
 **Intro to Tutorial Challenges
 
 def introTutorial(V, arr):
  return arr.index(V)
  
** Insertion Sort - Part 1

def insertionSort1(n, arr):
  temp = arr[n-1]
  i = n-1
  while i>0 and arr[i-1] >temp:
    arr[i] = arr[i-1]
    print(*arr)
    i -=1
  arr[i] = temp
  print(*arr)
  
**Insertion Sort - Part 2  
  
  
  def insertionSort2(n, arr):
  for j in range(1,n):
    key = arr[j]
    i = j
    while i>0 and arr[i-1]>key:
      arr[i] = arr[i-1]
      i-=1
    arr[i] = key
    print(*arr)
    
 ** Correctness and the Loop Invariant
 
def insertion_sort(l):
    for i in range(1, len(l)):
        j = i-1
        key = l[i]
        while (j >= 0) and (l[j] > key):
           l[j+1] = l[j]
           j -= 1
        l[j+1] = key
	
	
** Running Time of Algorithms
def runningTime(l):
  count = 0
  for i in range(1, len(l)):
        j = i-1
        key = l[i]
        while (j >= 0) and (l[j] > key):
           l[j+1] = l[j]
           count+=1
           j -= 1
        l[j+1] = key
  return count
  
** Quicksort 1 - Partition

def quickSort(arr):
  left, right, equal = [] , [] , []
  pivot = arr[0]
  for i in range(len(arr)):
    if arr[i]<pivot:
      left.append(arr[i])
    elif arr[i]==pivot:
      equal.append(arr[i])
    else:
      right.append(arr[i])
  return (left+equal+right) 
  
 ** Counting Sort 1
 
 def countingSort(arr):
  count = [0]*100
  for i in arr:
    count[i] +=1
  return count

**Counting Sort 2

def countingSort(arr):
  count = [0]*100
  for i in arr:
    count[i] +=1
  sort = []
  for i in range(0,len(count)):
    while count[i] !=0:
      count[i] -=1
      sort.append(i)
  return sort
      
      
 ** Closest Numbers
 def closestNumbers(arr):
  diff =9999999999
  arr.sort()
  n = len(arr)
  pair= []
  
  for i in range(1,n):
    d = abs(arr[i-1] - arr[i])
    if d<diff:
      diff = d
      pairs = [arr[i-1] , arr[i]]
    elif d == diff:
      pairs.extend([arr[i-1] , arr[i]])
  return pairs
  
** Find the Median
def findMedian(arr):
  arr.sort()
  n = len(arr)
  if n%2==0:
    median = ((arr[n//2]) + ((arr[n//2]+1)))//2
  else:
    median = arr[n//2]
  return median
  
  
 ** Ice Cream Parlor
 
 def icecreamParlor(m, arr): 
  for i in range(0,(len(arr)-1)):      
      for j in range(1,(len(arr)-0)):
        if arr[i] + arr[j]==m and i!=j:
          return [i+1,j+1]
	  
	  
**Missing Numbers

from collections import Counter
def missingNumbers(arr, brr):
  d1 = Counter(arr)
  d2 = Counter(brr)
  ans = d2 - d1
  return sorted(ans.keys())
  
 ** Sherlock and Array
 
 def balancedSums(arr):
  right = sum(arr)
  left = 0
  for i in arr:
    right -= i
    if left == right:
      return 'YES'
    left += i
  return 'NO'

**Minimum Absolute Difference in an Array
 
 def minimumAbsoluteDifference(arr):
  arr.sort()
  diff = sys.maxsize
  for i in range(1,len(arr)):
    diff = min (diff , abs(arr[i-1] - arr[i]))
  return diff


**Marc's Cakewalk

def marcsCakewalk(calorie):
  calorie.sort(reverse =True)
  n = len(calorie)
  summ = 0
  
  for i in range(n):
    ans = (2**i)*calorie[i]
    summ += ans
  return summ  
  
  
 ** Grid Challenge
 def gridChallenge(grid):
  grid = [list(row) for row in grid]
  r= len(grid)
  c = len(grid[0])
  for i in range(r):
    grid[i].sort()
 
  for j in range(c):
    for i in range(1,r):
      if not grid[i-1][j] <= grid[i][j]:
        
        return 'NO'     
  return 'YES'
  
 ** Luck Balance
 def luckBalance(k, contests):
  contest = {}
  for i,j in contests:
    if j not in contest:
      contest[j] = [i]
    else:
      contest[j].append(i)
  
  result = 0
  if 0 in contest:
    result = sum(contest[0])
  if 1 in contest:
    s = sorted(contest[1] , reverse = True)
    result += sum(s[:k])
    result -= sum(s[k:])
  return result
  
**  Maximum Perimeter Triangle

def maximumPerimeterTriangle(s):
  s.sort()
  i = len(sticks) - 3
  while i>=0 and s[i] +s[i+1] <= s[i+2]:
    i -=1
  if i>=0:
    return (s[i],s[i+1],s[i+2])
  else:
    return ([-1])
    
    
 **Beautiful Pairs
 
 from collections import Counter
def beautifulPairs(A, B):
  a = Counter(A)
  b = Counter(B)
  b_set = 0
  for i in a:
    if i in b:
      b_set +=  min(a[i] , b[i])
      
  if b_set == len(A):
    return b_set - 1
  else:
    return b_set +1
    
    
**Sherlock and The Beast

def decentNumber(n):
  m = n
  while m%3 != 0:
    m -=5
  if m<0:
    print(-1)
  else:
    print('5'*m , '3'*(n-m) , sep='')
    
 ** Priyanka and Toys
 
 def toys(w):
  w.sort()
  max_weight = w[0] +4
  count = 0 
  for i in w:
    if i <= max_weight:
      continue
    count +=1
    max_weight = i +4
  count +=1
  return count
  
  
 **Largest Permutation
 
 def largestPermutation(k, arr): 
  index = {}
  n = len(arr)
  for  i in range(n):
    index[arr[i]] =i
  swaps = i = 0
  while swaps < k and i<n:
    if arr[i] < n-i:
      idx = index[n-i]
      arr[i] , arr[idx] = arr[idx] ,arr[i]
      index[arr[idx]] = idx
      index[n-i] =i
      swaps +=1
    i += 1
  return arr

    
** Mark and Toys

  def maximumToys(prices, k):
  s = 0
  count = 0
  prices.sort()
  for i in range(len(prices)):
    s+= prices[i]
    if s <= k:
       count += 1
  return count
  
  
**Jim and the Orders

def jimOrders(orders):
  d= {}
  for i in range(len(orders)):
    s = sum(orders[i])
    if s not in d:
      d[s] = [i+1]
    else:
      d[s].append(i+1)
  result = []
  for  s in sorted(d.keys()):
    result.extend(d[s])
  return result
  
 ** Permuting Two Arrays
 
 def twoArrays(k, A, B):
  A.sort()
  B.sort(reverse = True)
  for i in range(len(A)):
    if A[i] + B[i] <k:
      return 'NO'
  return 'YES'
  
  **Lonely Integer
  
  def lonelyinteger(a):
  result = 0
  for i in a:
    result ^= i
  return result
  
 ** Maximizing XOR
 
 def maximizingXor(l, r):
  result = []
  for i in range(l,r+1):
    for  j in range(l,r+1):
      result.append(i^j)
  
  return max(result)
  
  
**  Sum vs XOR

def sumXor(n):
  result = 1
  while n:
    b = n&1
    n >>=1
    if b ==0:
      result *=2
  return result
  
**  Flipping bits

def flippingBits(n):
  return(2**32)+(~n)


**Game of Stones


def gameOfStones(n):
  
  if n%7<2:
    return 'Second'
  else:
    return 'First'
    
    
 ** Tower Breakers
 
 def towerBreakers(n, m):
  for i in range(t):
    if m ==1:
      return(2)
    else:
      if n%2==0:
        return('2')
      else:
        return('1')

  **A Chessboard Game
  
  def chessboardGame(x, y):
  if x%4 ==0 or x%4 == 3 or y%4 ==0 or y%4==3:
    return 'First'
  else:
    return 'Second'
    
 ** Introduction to Nim Game
 
 from functools import reduce
def nimGame(pile):
  if reduce(lambda x,y: x^y , pile) == 0:
    return 'Second'
  else:
    return 'First'
    
    
 ** MisÃ¨re Nim
 
 def misereNim(n):
  x=0
  for i in s:
    x ^= i
  if len(set(s)) == 1 and 1 in s:
    if x:
      return('Second')
    else:
      return('First')
  else:
    if x:
      return 'First'
    else:
      return "Second"
      
 ** Nimble Game
 
 t = int(input().strip())
for _ in range(t):
    n = int(input().strip())
    piles = list(map(int, input().strip().split(' ')))
    xor_sum = 0
    for n,pile in enumerate(piles):
        if pile % 2 == 1:
            xor_sum = xor_sum ^ n
    if xor_sum == 0:
        print('Second')
    else:
        print('First')
	
	
**Poker Nim	

def pokerNim(k, c):
  score = 0
  for i in c:
    score = score ^ i
    
  if score == 0:
    return 'Second'
  else:
    return 'First'
    
    
 ** XOR Strings
 
 def strings_xor(s, t):
    res = ""
    for i in range(len(s)):
        if s[i] == t[i]:
            res += '0';
        else:
            res += '1';

    return res

**Smart Number

def is_smart_number(num):
    val = int(math.sqrt(num))
    if num / val == val:
        return True
    return False
    
   **Balanced System File Partition 
    
   def mostBalancedPartition(parent, files_size):
  
  n = len(files_size)
  s = [0 for i in range(n)]
  for i in range(n):
    cur = i
    while(cur != -1):
      s[cur] += files_size[i]
      cur = parent[cur]
      
      ans = abs(s[0] - 2*s[1])
  for i in range(2,n):
    temp = abs(s[0] - 2*s[i])
    if ans>temp:
      ans = temp
      
  return ans
  
  
  **Queen's Attack II
  
  def queensAttack(n, k, r_q, c_q, obstacles):
  total = 0
  obs = {}
  for i, j in obstacles:
    if i in obs:
      obs[i][j] = 1
    else:
      obs[i] = {j:1}
  def limit(x,y):
    return True if 1<=x<=n and 1<=y<=n else False
  
  def check (x,y,xi,yi):
    count = 0
    x += xi
    y += yi
    while limit(x,y) and obs.get(x,{}).get(y,0) ==0:
      count +=1
      x+= xi
      y+=yi
    return count
  r = [0,0,-1,1,-1,1,-1,1]
  c= [1,-1,0,0,-1,1,1,-1]
  
  for i, j in zip(r,c):
    total += check(r_q, c_q , i , j)
  return total
      
  **Bigger is Greater
  def biggerIsGreater(w):
  result = ''
  n = len(w)
  w = list(w)
  i = n-2
  while i>=0 and w[i]>=w[i+1]:
    i -=1
  if i == -1:
    result = 'no answer'
  else:
    j = n-1
    while j>= i and w[j] <= w[i]:
      j -=1
    w[i] , w[j] = w[j] , w[i]
    w = ''.join(w)
    result = w[:i+1] + w[i+1:][::-1]
  return result
      
 **The Time in Words
 
 def timeInWords(h, m):
    res = ''
    numbers = ['','one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve', 'thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen','twenty']
    minute = 'minute'
    
    if m != 1:
        minute += 's'
        
    if m == 0:
        res = numbers[h] + " o' clock"
    elif m == 30:
        res = "half past " + numbers[h]
    elif m == 15:
        res = "quarter past " + numbers[h]
    elif m == 45:
        res = "quarter to " + numbers[h + 1]
    elif m < 20:
        res = numbers[m] + ' ' + minute + ' past ' + numbers[h]
    elif m < 30:
        res = numbers[-1] + ' ' + numbers[int(m%10)] + ' ' + minute + ' past ' + numbers[h]
    elif m > 45:
        res = numbers[60 - m] + ' ' + minute + ' to ' + numbers[h + 1]
    elif m > 30:
        res = numbers[-1] + ' ' + numbers[int(m%10)] + ' ' + minute + ' to ' + numbers[h + 1]
    
    return res.replace('  ', ' ')
  
 ** The Grid Search
 
 def gridSearch(G, P):
  def check(x,y):
    for i in range(r):
      if P[i] != G[x+i][y:y+c]:
        return False
      
    return True
      
  for i in range(R):
    for j in range(C):
      if G[i][j] == P[0][0]:
        if check(i,j):
          return 'YES'
  return 'NO'

**Cycle Detection	

def has_cycle(head):
  slow = fast = head
  while fast != None and fast.next != None:
    slow = slow.next
    fast = fast.next.next
    if fast == slow:
      return '1'
  return '0'
  
  **3D Surface Area
  
  def surfaceArea(A):
  area = 2*H*W
  def check(i,j):
    return A[x+i][y+j] if 0<=x+i<H and 0<=+y+j<W else 0
  
  xi = [0,0,1,-1]
  yi = [1,-1,0,0]
  for x in range(H):
    for y in range(W):
      for i, j in zip(xi,yi):
        area+= max(0, A[x][y] - check(i,j))
  return area
	
	
**Absolute Permutation

def absolutePermutation(n, k):
  arr=list(range(n+1))
  if k ==0:
    return arr[1:]
  if n%2==1:
    return [-1]
  for i in range(1,n-k+1):
    if arr[i] == arr[i+k] - k:
      arr[i] , arr[i+k] = arr[i+k] , arr[i]
    elif abs(arr[i] - i) !=k:
      return [-1]
  for i in range(n-k+1 , n+1):
    if abs(arr[i] - i) !=k:
      return [-1]
  return arr[1:]
    
    
 


    
    
    
   
    
   
  
  
  
  
  
  
  

	    
	 
	 
	 
	  
    
  
  

      
      
 















